@require: class-slydifi/slydifi
@require: math
@require: enumitem/enumitem
@require: azmath/azmath
@require: figbox/figbox
@require: easytable/easytable
@import: CyanTheme

open SlydifiOverlay
open FigBox
open EasyTableAlias
open CyanTheme
let-block ctx +block-skip v = block-skip v
let-inline ctx \inline-skip v = inline-skip v
let-inline ctx \fil = inline-fil
let gen-iop it =
  let iop =
    text-in-math MathOp (fun ctx -> (let size = get-font-size ctx in
      raise-inline (size *' 0.12) (read-inline (ctx
        |> set-font-size (size *' 0.7)) { ${#it} }))) in iop
let-math \isum = gen-iop ${\sum}
let-math \iprod = gen-iop ${\prod}
let-math \mH a b =
  let nil = text-in-math MathOrd (fun ctx -> inline-nil) in
  let a = ${#nil_#a} in
  let b = ${#nil_#b} in
  let c = ${H} in ${#a #c #b}
let-math \mod = ${\  \mathrm{mod} \ }
let-block +ffffx id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: Kyo_s_s }) { |#id;: f(f(f(f(f(x)))))| } <
        +frame ?:(2) {} <
          +p {
            整数 ${K \  ( 1 \leq K \leq 1 0^{1 8} )} と ${x} についての関数 ${f ( x )} が与えられる．
            最初 ${x = 1} として，次の操作を ${K} 回繰り返す:
            \listing { * ${x} を ${f ( x )} で更新する } 最終的な ${x}\emph { ${\mod 9 9 8} } は？
          }
          +block-skip (15pt);
          +phantom (from 2) <
            +p { 構文解析をがんばる必要がある...？ }
            +p { ${\to} めちゃめちゃな式は与えられないため，そんなに頑張らなくてよい． }
          >
        >
        +frame ?:(2) { 部分点1解法 } <
          +listing { * ${K = 1 , \  \  f ( x ) \text!{に `*`, `^` は含まれない．}} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { ${f ( x )} は， ${x} もしくは ${1} 以上 ${1 0^9} 未満の整数 の和で表されているので， }
            +block-skip (5pt);
            +enumerate ?:(let step idx =
              let it =
                idx
                  |> arabic
                  |> embed-string in { step #it;.\ } in EnumitemAlias.index-label step) {
              * ${f ( x )} を `+` で分割する
              * 分割したそれぞれの文字列を数値に変換する ( ${x} なら ${1} )
              * すべて足し合わせる
            }
            +block-skip (5pt);
            +p { を実装すればOK． }
          >
        >

        +frame ?:(3) { 部分点2解法 } <
          +listing { * ${K \leq 1 0^4 , \  \  f ( x ) \text!{に `^` は含まれない．}} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 部分点1解法で，「数値/ ${x} と演算子 `+`のみからなる数式」を計算した． }
            +p { ${\to} 改造すると，「数値/ ${x} と 演算子 `*`のみからなる数式」を計算できる． }
          >
          +phantom (from 3) <
            +enumerate ?:(let step idx =
              let it =
                idx
                  |> arabic
                  |> embed-string in { step #it;.\ } in EnumitemAlias.index-label step) {
              * ${f ( x )} を `+` で分割する
              * 分割したそれぞれの文字列は「数値/ ${x} と 演算子 `*`のみからなる数式」なので，
              それぞれを計算する
              * すべて足し合わせる
            }
            +block-skip (5pt);
            +p { そのままだとオーバーフローするため，和/積の計算時に ${\mod 9 9 8} を取ればOK． }
          >
        >

        +frame ?:(2) { 部分点3解法 } <
          +listing { * ${K \leq 1 0^4} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 「数値/ ${x} と 演算子 `*`, `^`のみからなる数式」 を計算できればOK．これは， }
            +enumerate ?:(let step idx =
              let it =
                idx
                  |> arabic
                  |> embed-string in { step #it;.\ } in
              EnumitemAlias.with-depth [
                EnumitemAlias.index-label step;
                EnumitemAlias.bullet;
              ]) {
              * ${f ( x )} を `*` で分割する
              * 分割したそれぞれの文字列は「数値/ ${x} もしくは，演算子 `^`のみからなる数式」なので，
               ** `^` を含む: `(数値 or x)^(数値)` の形になっているので計算する
               ** `^` を含まない: そのまま数値に変換する
              * すべて掛け合わせる
            }
            +p { とすれば実装できる．愚直に ${K} 回シミュレーションすればOK． }
          >
        >

        +frame ?:(3) { 満点解法 } <
          +phantom (from 2) <
            +p {
              関数 ${f ( x )} の形から，
              ${x} を更新するときに ${x \mod 9 9 8} で更新してもよい．
              つまり，関数 ${f} は，
            }
            +eqn (${f : \mathbb{Z} / 9 9 8 \mathbb{Z} \to \mathbb{Z} / 9 9 8 \mathbb{Z}});
            +p { とみなせる． ${\to} ダブリングできる！ }
          >
          +block-skip (5pt);
          +phantom (from 3) <
            +p {
              前処理として ${x = 0 , 1 , \ldots , 9 9 7} に対する
              ${f ( x )} を計算しておくことにより， ${x = 0 , 1 , \ldots , 9 9 7} に対する
              ${f ( f ( x ) )} の値が計算でき，さらにこの値を用いて ${x} に対する ${f ( f ( f ( f ( x ) ) ) )} の値が計算でき， ${\ldots}
            }
            +p { これを繰り返し，必要な部分を適用することで ${K} 回操作した後の値を求めることができる！ }
          >
        >

        +frame { 余談 } <
          +block-skip (5pt);
          +listing {
            * 原案では 引き算 `-` と 括弧 `()` も含まれていたのですが，さすがにやりすぎということで無くしました．
             ** 括弧が入ってくるとちゃんと再帰的な処理をする必要があります．
          }
          +block-skip (5pt);
          +listing {
            * `^` もなくていいじゃん，と言われていたのですが，
            `^` が無いとPythonの`eval`を使うことで構文解析をサボれてしまうのでやむなく入れました．
             ** 部分点2までは `eval` をやるだけで通せます．
             ** 部分点3も，`re.sub(r'(x|\d+)\^(\d+)', r'pow(\1,\2,998)', S)` と置換することで，
            構文解析パートは `eval` で済ませることができます(ダブリングはする必要があります)．
          }
        >
      >
    >
let-block +x-word-database id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: Kyo_s_s }) { | #id;: X-word Database | } <
        +frame ?:(2) {} <
          +p { 整数 ${X \  \p{4 \leq X \leq 10^5}} と文字列 ${S \  ( 1 \leq \abs{S} \leq X )} が与えられる． }
          +p {
            以下の条件を満たす文字列を\emph { よい文字列 }と呼ぶ:
            \listing {
              * 文字列の長さが ${X} 以下
              * 辞書順で ${S} 以下
              * 連続部分列に`cyan`を含む
            } よい文字列は何個ある？
          }
          +block-skip (15pt);
          +phantom (only 2) <
            +p { ${X = 5 , \  S =} `cyanc` のとき，条件を満たす文字列は， }
            +p { \fil; `acyan`, `bcyan`, `ccyan`, `cyan`, `cyana`, `cyanb`, `cyanc` }
            +p { の${7}個． }
          >
        >
        +frame ?:(3) { 部分点1解法 } <
          +listing { * ${X \leq 8} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { `cyan` を含む長さ ${8} 以下の文字列を全て試せばOK． }
            +block-skip (10pt);
            +p { たとえば長さが ${8} で `cyan` を含む文字列は， }
            +p { \fil; `****cyan`, `***cyan*`, `**cyan**`, `*cyan***`, `cyan****` }
            +p {
              のどれかの形なので，`*` に入るアルファベットを全て試して
              それぞれがよい文字列かどうかを判定すればよい！
            }
          >
          +block-skip (15pt);
          +phantom (from 3) <
            +p { このままだと ${X = 8} で `cyancyan` を ${2} 回数えてしまうのでそこだけ注意． }
          >
        >
        +frame ?:(4) { 部分点2解法 } <
          +listing { * ${X \leq 1 0^3 , \  S} はすべて `z` で長さが ${X} の文字列 }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 長さが ${X} 以下で `cyan` を含むような文字列はすべてよい文字列になる． }
          >
          +phantom (from 3) <
            +align [
              ${\mathrm{dp} \pB{i} \pB{j} :=};
              ${X \text!{ の上から} i \text!{番目まで見て，}};
              ${};
              ${\text!{`cyan`の} j \text!{文字目までを末尾に含む} \/ \text!{すでに`cyan`を含む}};
              ${};
              ${\text!{ような文字列の個数}};
            ];
            +p {
              としてDPすることで， ${\mathrm{dp} \pB{i} \pB{\text!{`cyan` を含む}}} の値は
              「`cyan` を連続部分列に持つ，ちょうど${i} 文字の文字列の個数」となる．
            }
          >
          +phantom (from 4) <
            +block-skip (5pt);
            +p {
              ${\to} これらの和をとり，
              ${\isum_{i = 1}^X \mathrm{dp} \pB{i} \pB{\text!{`cyan` を含む}}}
              が答え．
            }
          >
        >
        +frame ?:(3) { 満点解法 } <
          +phantom (from 2) <
            +p { 桁DPで解ける！ }
            +align [
              ${\mathrm{dp} \pB{i} \pB{\mathrm{smaller}} \pB{j} :=};
              ${X \text!{の上から} i \text!{番目まで見て，}};
              ${};
              ${\mathrm{smaller} = 0 : X \text!{と同じ} \/ \  1 : X \text!{より小さく，}};
              ${};
              ${\text!{`cyan`の} j \text!{文字目までを末尾に含む} \/ \text!{すでに`cyan`を含む}};
              ${};
              ${\text!{文字列の個数}};
            ];
          >
          +phantom (from 3) <
            +p { 上からDPをしていくことで， ${X} 字以下の文字列の個数も求められている． }
            +eqn (${\sum_{i = 0}^X \p{\mathrm{dp} \pB{i} \pB{0} \pB{\text!{`cyan`を含む}} + \mathrm{dp} \pB{i} \pB{1} \pB{\text!{`cyan`を含む}}}});
            +p { が答え． }
          >
        >
      >
    >
let-block +cyan-or-less id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: Kyo_s_s }) { |#id;: Cyan or Less| } <
        +frame {} <
          +block-skip (10pt);
          +p { カラーコードが文字列で与えられる． }
          +block-skip (5pt);
          +p {
            \emph { 彩度 } を以下で定義する:
            \listing { * ${r , g , b} をカラーコードのRGB値とする． } \eqn (${\text!{彩度} = \frac{\max \p{r, g, b} - \min \p{r, g, b}}{\max \p{r, g, b}}});
          }
          +block-skip (5pt);
          +p { 与えられたカラーコードが表す色は水色 `#00c0c0` の彩度以下か判定せよ． }
        >
        +frame ?:(3) { 解法 } <
          +p { step1.\ 与えられたカラーコードをRGB値に変換する． }
          +listing {
            * 2桁の16進数を10進数に変換するには，1つ目の数字を16倍して2つ目の数字を足せばよい．
             ** `a` は ${1 0} に，`b` は ${1 1} に，...，`f` は ${1 5} に変換してから足す．
          }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { step2.\ 彩度を計算する． }
            +listing { * 彩度の定義通りに計算すればOK． }
          >
          +block-skip (5pt);
          +phantom (from 3) <
            +p { step3.\ 彩度が水色の彩度以下か判定する． }
            +listing { * 水色 `#00c0c0` も同じ方法で彩度を計算しておけば，大小関係を比較するだけ． }
          >
        >
        +frame { 余談 } <
          +block-skip (25pt);
          +p { 実は，水色 `#00c0c0` の彩度は ${1} }
          +p { ${\to} 彩度がこれより大きくなる色は存在しない！ }
          +block-skip (10pt);
          +p { このため，すべてのケースで `Yes` と正解すればよいです． }
          +block-skip (20pt);
          +p { 一旦没になったのですが，丁寧に書いてもよいし，気づけば1行で解けるので面白くない？となり出題されました． }
        >
      >
    >
let-block +unions id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: yasunori }) { |#id;: Unions| } <
        +frame {} <
          +p {
            ${N \  ( 2 \leq N \leq 1 0^5 )} 個の国と， 複数の国による同盟が
            ${M \  ( 1 \leq M \leq 1 0^5 )} 個あり，
          }
          +p {
            ${i} 個目の同盟には ${C_i} 個の国
            ${A_{i , 1} , A_{i , 2} , \ldots , A_{i , C_i}} の国が所属している．\br; (ここで， ${C_i} は ${\isum_{i = 0}^M C_i \leq 1 0^5} を満たす．)
          }
          +block-skip (5pt);
          +p {
            同じ同盟に所属している国同士は直接行き来でき，同盟 ${i} に属している国同士は ${D_i} 分で移動できる．
            同じ同盟に属していない国同士は直接行き来できない．
          }
          +block-skip (5pt);
          +p { 国 ${2 , 3 , \ldots , N} について，国 ${1} から移動するのにかかる時間の最小値を求めよ． }
        >
        % +frame {} <
        %   +p {
        %     ${N} 個の国と，複数の国で構成される同盟が ${M} 個ある．
        %     ${i} 個目の同盟には ${C_i} 個の国
        %     ${A_{i , 1} , A_{i , 2} , \ldots , A_{i , C_i}} の国が所属している．
        %   }
        %   +p {
        %     同じ同盟に所属している国同士は直接行き来でき，同盟 ${i} に属している国同士は ${D_i} 分で移動できる．
        %     同じ同盟に属していない国同士は直接行き来できない．
        %   }
        %   +p { 国 ${2 , 3 , \ldots , N} について，国 ${1} から移動するのにかかる時間の最小値を求めよ． }
        %   +block-skip (5pt);
        %   +listing {
        %     * ${2 \leq N \leq 1 0^5}
        %     * ${1 \leq M \leq 1 0^5}
        %     * ${\isum_{i = 1}^M C_i \leq 1 0^5}
        %   }
        % >
        +frame ?:(3) { 部分点1解法 } <
          +listing { * ${C_i = 2 \  ( 1 \leq i \leq M )} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p {
              すべての同盟がちょうど ${2} 個の国からなるため，
              同盟 ${i} は「${A_{i , 1}} と ${A_{i , 2}} は移動に ${D_i} 分かかる道でつながっている」と言い換えることができる．
            }
          >
          +block-skip (10pt);
          +phantom (from 3) <
            +p { つまり，国 ${1} から国 ${2 , 3 , \ldots , N} への最短距離を求める問題に帰着できる． }
            +p { ${\to} このグラフは頂点の数が ${N} ，辺の数が ${M} であるため，ダイクストラ法で解ける！ }
            +block-skip (10pt);
            +p { 国 ${1} を始点として，ダイクストラ法を使って各国への最短距離を求めることで，部分点1に正解できる． }
          >
        >
        +frame ?:(3) { 部分点2解法 } <
          +listing { * ${\isum_{i = 1}^M C_i \leq 1 0^3} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 同じ同盟に属する国同士は「${D_i} 分かかる道でつながっている」と言い換えることができる． }
          >
          +phantom (from 3) <
            +p {
              ${\isum_{i = 1}^M C_i \leq 1 0^3} の制約から，
              同じ同盟に属する国同士のペアすべてに ${D_i} の重みを持つ辺を張っても十分間に合う．
              実際，辺数を ${\abs{E}} とすると，
            }
            +eqn (${\abs{E} = \sum_{i = 1}^M \frac{C_i (C_i - 1)}{2} < \frac{1}{2} \sum_{i = 1}^M C_i^2 \leq \frac{1}{2} \p{\sum_{i=1}^M C_i}^2 \leq 5 \times 1 0^5});
            +p { となる． }
            +p { 部分点1と同様にダイクストラ法を用いれば，部分点2に正解できる． }
          >
        >
        +frame ?:(3) { 満点解法 } <
          +phantom (from 2) <
            +p { 部分点2の方法だと，張る辺の本数が多すぎて間に合わない． }
            +p { \emph { 超頂点 } を導入することで間に合う！ }
          >
          +block-skip (2pt);
          +phantom (from 3) <
            +p { 各国 ${1 , 2 , \ldots , N} と，同盟 ${1 , 2 , \ldots , M} を頂点とするグラフを考える． }
            +p {
              ${i = 1 , 2 , \ldots , M , \  j = 1 , 2 , \ldots , C_i} について，
              \listing {
                * 国 ${A_{i , j}} から 同盟 ${i} に，重み ${D_i} の辺を張る
                * 同盟 ${i} から 国 ${A_{i , j}} に，重み ${0} の辺を張る
              }
            }
            +p { とすると，同じ同盟に属する国同士は同盟の頂点を経由することで ${D_i} 分のコストで移動できる． }
            +p { このグラフの辺数は ${2 \times \isum_{i = 1}^M C_i} であるため，このグラフ上でダイクストラ法をすればよい． }
          >
        >
      >
    >
let-block +range-rotate-query id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: loop0919 }) { | #id;: Range Rotate Query| } <
        +frame ?:(1) {} <
          +block-skip (5pt);
          +p { 二次元平面上に ${N \  ( 3 \leq N \leq 1 0^5 )} 個の点がある． }
          +p {
            以下のクエリを ${Q \  ( 1 \leq Q \leq 5 0 0 0 0 )} 個処理せよ:
            \listing {
              * 原点からのユークリッド距離が ${\sqrt{l}} 以上 ${\sqrt{r}} 以下の点
              すべてを反時計回りに ${\theta} 度回転させる
              * 点 ${a , b , c} を頂点とする三角形の面積を出力する
            }
          }
        >
        +frame ?:(3) { 部分点1解法 } <
          +listing { * ${N \leq 1 0 0 , \  Q \leq 1 0 0 0 ,} 面積を求めるクエリのみ }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { ${3}点 ${\p{ x_1 , y_1 } , \p{ x_2 , y_2} , \p{ x_3 , y_3 }} を頂点とする三角形の面積を求めたい． }
          >
          +block-skip (5pt);
          +phantom (from 3) <
            +p {
              このとき，三角形の面積は，
              \eqn (${\frac{1}{2} \cdot \abs{x_1 y_2 + x_2 y_3 + x_3 y_1 - x_1 y_3 - x_2 y_1 - x_3 y_2}}); で求められる(証明はここでは略)．
            }
            +block-skip (5pt);
            +p { クエリごとにこれを計算すればOK． }
          >
        >
        +frame ?:(3) { 部分点2解法 } <
          +listing { * ${N \leq 1 0 0 , \  Q \leq 1 0 0 0} }
          +phantom (from 2) <
            +p {
              ある頂点 ${\p{x, y}} を ${\theta} 度反時計回りに回転させると，その座標は，
              \eqn (let-math \th = ${\frac{\theta \pi}{180}} in ${\p{x \cos \th - y \sin \th,\ x \sin \th + y \cos \th}}); で求められる(証明はここでは略．回転行列を用いればよい)．
            }
          >
          +phantom (from 3) <
            +p { 各点について，何度回転したかを記録しておけば， }
            +listing {
              * 回転クエリ: 距離が ${\sqrt{l}}以上 ${\sqrt{r}} 以下の点の回転した度数を ${\theta} だけ増やす
              * 面積クエリ: ${3} 点それぞれの今の座標を求めたのち，面積を計算する
            }
            +p { とすれば部分点2に正解できる． }
            +p { 毎回回転させると誤差で落ちるので注意！ }
          >
        >
        +frame ?:(3) { 満点解法 } <
          +phantom (from 2) <
            +p {
              各点をユークリッド距離でソートしておくと，
              回転クエリは，「${\sqrt{l}} 以上 ${\sqrt{r}} 以下の区間に ${\theta} を加算する」という操作になる．
            }
            +listing { * 実際に加算する区間は二分探索をしたりすれば求められる． }
            +p { 区間加算一点取得ができればよい． }
            +p { ${\to} BIT(fenwick tree)でできる！ }
          >
          +phantom (from 3) <
            +listing {
              * 区間 ${[ l , r )} に ${x} を加算:
               ** ${l} 番目の要素に ${x} を加算， ${r} 番目の要素に ${- x} を加算
              * ${i} 番目の要素を取得:
               ** ${[ 0 , i )} の総和が求めたい値
            }
            +p { BIT上でimos法をするイメージ． }
          >
        >
      >
    >
let-block +counting-zig-zag-sequence id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: Ackvy }) { |#id;: Counting Zig Zag Sequence | } <
        +frame {} <
          +p { 正整数 ${N \  ( 1 \leq N \leq 5 0 0 0 ) , \  K \  ( 1 \leq K \leq 5 0 0 0 )} が与えられる． }
          +p {
            次のような数列を \emph { ジグザグ数列 }と呼ぶ:
            \listing {
              * 連続する ${2} 項が異なる
              * 各 ${i \  ( 1 \leq i \leq N - 2 )} について， ${\p{A_i - A_{i + 1}} \p{A_{i + 1} - A_{i + 2}} \leq 0} を満たす
               ** 増加 ${\to} 減少 ${\to} 増加 ${\to \cdots} または 減少 ${\to} 増加 ${\to} 減少 ${\to \cdots}
            }
          }
          +p { 長さが ${N} ，各要素が ${1} 以上 ${K} 以下の整数からなるジグザグ数列の個数を求めよ． }
          +block-skip (10pt);
          +p {
            たとえば， ${( 2 , 7 , 1 , 8 , 2 , 8 )} はジグザグ数列だが，
            ${( 3 , 1 , 4 , 1 , 5 , 9 )} はジグザグ数列ではない．
          }
        >
        +frame ?:(2) { 部分点1解法 } <
          +listing { * ${N \leq 5 , \  K \leq 5} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 長さが ${N}，各要素が ${K} 以下の正整数からなる数列を全探索し，ジグザグ数列かどうかを判定すればOK． }
            +p { 長さが ${N}，各要素が ${K} 以下の正整数からなる数列は合計で ${K^N} 個あり， }
            +p { ${N \leq 5 , \  K \leq 5} の制約であればすべての数列を試すことができる． }
            +block-skip (5pt);
            +p { ${0} から ${K^N} まで， ${K} 進数として考えると実装が楽． }
          >
        >
        +frame ?:(3) { 部分点2解法 } <
          +listing { * ${N \leq 5 0 0 0 , \  K \leq 5 0} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p {
              ${N = 1} のとき，定義よりジグザグ数列は ${K} 個．
              ${N \geq 2} について考える．
            }
          >
          +phantom (from 3) <
            +block-skip (5pt);
            +p {
              次のようなDPを考える:
              \align (let-math \inc = ${\text!{\inline-skip(6pt); 減少}} in
              let-math \dec = ${\text!{\inline-skip(6pt);増加}} in
                [
                  ${\mathrm{dp} [ i ] [ j ] [ \mathrm{increased} ] :=};
                  ${i \text!{番目の要素が} j \text!{で，}};
                  ${};
                  ${\text!{次の要素が} \mathrm{increased} = 0 : \inc \/ \  1 : \dec};
                  ${};
                  ${\text!{するべきなジグザグ数列の個数}};
                ]); 初期値は ${\mathrm{dp} [ 1 ] [ \star ] [ \star ] = 1} ．
            }
          >
        >
        +frame ?:(2) { 部分点2解法 } <
          +listing { * ${N \leq 5 0 0 0 , \  K \leq 5 0} }
          +block-skip (5pt);
          +p {
            ${\mathrm{dp} [ i + 1 ] [ j ] [ 0 ]} は，
            「 ${i} 番目の要素が ${j} より小さく，次に増加する」ような ${\mathrm{dp}} 配列の要素の和で求められる．
            \listing {
              * 「 ${i} 番目の要素が ${j} より小さく，次に増加する」ような数列は，
              ${i + 1} 番目の要素を ${j} にしてもジグザグ数列を保つ．
            }
          }
          +phantom (from 2) <
            +p {
              ${\mathrm{dp} [ i + 1 ] [ j ] [ 1 ]} も同様に考えると，遷移は，
              \eqn (${\mathrm{dp} [ i + 1 ] [ j ] [ 0 ] = \isum_{k = 1}^{j - 1} \mathrm{dp} [ i ] [ k ] [ 1 ]}); \eqn (${\mathrm{dp} [ i + 1 ] [ j ] [ 1 ] = \isum_{k = j + 1}^{K} \mathrm{dp} [ i ] [ k ] [ 0 ]});
            }
            +p { となる．答えは， ${\isum_{j = 1}^K \p{\mathrm{dp} [ N ] [ j ] [ 0 ] + \mathrm{dp} [ N ] [ j ] [ 1 ]}} ． }
          >
        >
        +frame ?:(2) { 満点解法 } <
          +p {
            部分点2解法のDP:
            \eqn (${\mathrm{dp} [ i + 1 ] [ j ] [ 0 ] = \isum_{k = 1}^{j - 1} \mathrm{dp} [ i ] [ k ] [ 1 ]}); \eqn (${\mathrm{dp} [ i + 1 ] [ j ] [ 1 ] = \isum_{k = j + 1}^{K} \mathrm{dp} [ i ] [ k ] [ 0 ]}); を愚直に書くとTLEしてしまうが， ${\isum} の部分を累積和で前計算しておくことにより，
            ${N \leq 5 0 0 0 , \  K \leq 5 0 0 0} の制約で高速に答えを求めることができる．
          }
          +block-skip (5pt);
          +phantom (from 2) <
            +p {
              増加 ${\to} 減少 ${\to} 増加 ${\to \cdots} となるようなジグザグ数列の個数を求めたのち，
              答えを ${2} 倍してもよい．
              \listing {
                * こうすると，次に増加/減少する を状態として持たなくてもよくなる．
                * 偶奇で場合分けすればOK．
              }
            }
          >
        >
      >
    >
let-inline ctx \br = inline-fil ++ embed-block-breakable ctx (block-skip (get-natural-width (read-inline ctx { m })))
let-block +subset-mex id =
  let-math \mex = ${\mathrm{mex}} in
  let id = embed-string id in
    '<
      +section ?:({ Writer: Kyo_s_s }) { |#id;: Subset Mex | } <
        +frame {} <
          +p {
            ${N \  \p{1 \leq N \leq  2 \times 10^5}} 枚のカードがあり，
            ${i} 番目のカードには \br; 整数 ${A_i \  \p{0 \leq A_i \leq 2 \times 10^5}} が書かれている．
          }
          +p { ${N} 枚のカードの中から ${1} 枚以上カードを選ぶ方法をすべて考え，それぞれの選び方の ${\mex} の総和を求めよ． }
          +block-skip (10pt);
          +p {
            たとえば， ${A = \p{0, 1, 1, 2}} で，
            \listing {
              * ${\p{1, 3 }} 枚目のカードを選んだとき， ${\mex \p{A_1, A_3} = \mex \p{0, 1} = 2} ．
              * ${\p{1, 2, 4}} 枚目のカードを選んだとき， ${\mex \p{A_1, A_2,A_4} = \mex \p{0, 1, 2} = 3} ．
            } このほか，すべての選び方についての ${\mex} の総和は ${1 7} となる．
          }
        >
        +frame ?:(3) { 部分点1解法 } <
          +listing { * ${N \leq 1 7 , \  A_i \leq 1 0 0 0} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p {
              ${N} 枚のカードから ${1} 枚以上選ぶ方法は
              ${2^N - 1} 通り． ${N = 1 7} のとき ${1 3 1 0 7 1} 通りしかないので，
              すべての選び方を試して ${\mex} の総和を求めればOK．
            }
          >
          +phantom (from 3) <
            +block-skip (10pt);
            +p { すべての選び方を列挙するには bit 全探索をすればよい． }
            +block-skip (5pt);
            +p {
              ${1} から ${2^N} までをループで回し，
              立っているビットに対応するカードを選んでいるとすれば実装が楽．
            }
          >
        >
        +frame ?:(1) { 部分点2解法 } <
          +listing { * ${A_i \leq 1 0 0 0} }
          +block-skip (5pt);
          +p {
            ${A_i \leq 1 0 0 0} の制約から，どのようなカードの選び方をしても
            ${\mex} の最大値は ${1 0 0 1} 以下である．
          }
          +p {
            ${\to x = 1 , 2 , \ldots , 1 0 0 1} に対して，
            ${\mex} が ${x} になるようなカードの選び方が何通りあるか求められればよい．
          }
          +block-skip (5pt);
          +p {
            ${\mex} が ${x} になるためには ${\ldots} \listing {
              * ${0 , 1 , \ldots , x - 1} がそれぞれ ${1} 枚以上選ばれている
              * ${x} が選ばれていない
              * ${x + 1} 以上の数は選ばれているか選ばれていないかは関係ない
            }
          }
        >
        +frame ?:(1) { 部分点2解法 } <
          +p {
            ${c ( x )} を ${A} の中に含まれる ${x} の個数 とすると，
            ${\mex} が ${x} になるようなカードの選び方の個数は，
            \listing {
              * ${0 , 1 , \ldots , x - 1} がそれぞれ ${1} 枚以上選ばれている \br; ${\to \p{2^{c(0)} - 1} \times \p{2^{c(1)} - 1} \times \cdots \times \p{2^{c(x - 1)} - 1}} 通り
              * ${x} が選ばれていない \br; ${\to 1} 通り
              * ${x + 1} 以上の数は選ばれているか選ばれていないかは関係ない \br; ${\to 2^{c ( x + 1 )} \times 2^{c ( x + 2 )} \times \cdots \times 2^{c ( 1 0 0 2 )}} 通り
            } これらの積が，${\mex} が ${x} になるようなカードの選び方の個数．
          }
          +p { 各 ${x} についてこの値を求め， ${x} を掛けたのちに足し合わせればよい． }
        >
        +frame ?:(2) { 満点解法 } <
          +p { 部分点2解法の方法を高速化することを考える． }
          +p {
            ${x = 1 , 2 , \ldots , 2 \times 1 0^5 + 1} に対して，以下を求めたい:
            \eqn (${f ( x ) := \prod_{i = 0}^{x - 1} \p{2^{c(i) - 1}} \times \prod_{i = x + 1}^{2 \times 1 0^5 + 2} 2^{c ( i )}});
          }
          +phantom (from 2) <
            +listing {
              * ${S_i = \prod_{j = 0}^i \p{2^{c ( j )}-1} \ } とすると，これは前から順に求めれば高速．
              * ${T_i = \prod_{j = i}^{2 \times 1 0^5 + 2} 2^{c ( j )} \ } とすると，これは後ろから順に求めれば高速．
            }
            +p {
              これより， ${f ( x )} は ${S_{x - 1} \times T_{x + 1}} で求められる．
              答えは ${\isum_{x = 1}^{2 \times 1 0^5 + 1} \p{x \times f ( x )}} ．
            }
          >
        >
      >
    >
let-block +long-chess-board id =
  let id = embed-string id in
  let sz = 35pt in
  let base = 0pt in
  let h = 105pt in
  let imageh3-fb-base =
    let h = 105pt in
    let w = 525pt in
    let sz = 35pt in
    let lc = Color.gray 0.5 in
    let paint-k i j =
      let i = float i in
      let j = float j in
      let p = 1pt in
      let sx = sz *' i +' p in
      let sy = sz *' j +' p +' base in
      let gx = sz *' (i +. 1.) -' p in
      let gy = sz *' (j +. 1.) -' p +' base in stroke 2pt Color.red (Gr.rectangle (sx, sy) (gx, gy)) in
    let paint-b i j =
      let i = float i in
      let j = float j in stroke 2pt Color.blue (Gr.circle (sz *' i +' sz *' 0.5, sz *' j +' sz *' 0.5 +' base) (sz *' 0.5 -' 2pt)) in
    let paint-text ctx i j inner =
      let i = float i in
      let j = float j in
        draw-text (sz *' i +' sz *' 0.26, sz *' j +' sz *' 0.25 +' base) (read-inline (ctx
          |> set-font-size 23pt) inner) in
    let arrow color sx sy gx gy = Gr.arrow 1pt color 12pt 10pt 4pt (sx, sy) (gx, gy) in
    let arrow-up i j ni nj =
      let sx = sz *' (float i) +' sz in
      let sy = sz *' (float j) +' sz *' 0.75 in
      let gx = sz *' (float ni) in
      let gy = sz *' (float nj) +' sz *' 0.25 in arrow Color.red sx (sy +' base) gx (gy +' base) in
    let arrow-down i j ni nj =
      let sx = sz *' (float i) +' sz in
      let sy = sz *' (float j) +' sz *' 0.25 in
      let gx = sz *' (float ni) in
      let gy = sz *' (float nj) +' sz *' 0.75 in arrow Color.red sx (sy +' base) gx (gy +' base) in
      from-graphics (w, h +' base) [
        stroke 1pt lc (Gr.line (0pt, base) (w, base));
        stroke 1pt lc (Gr.line (0pt, base +' sz) (w, base +' sz));
        stroke 1pt lc (Gr.line (0pt, base +' sz *' 2.) (w, base +' sz *' 2.));
        stroke 1pt lc (Gr.line (0pt, base +' sz *' 3.) (w, base +' sz *' 3.));
        stroke 1pt lc (Gr.line (0pt, base) (0pt, base +' h));
        stroke 1pt lc (Gr.line (sz, base) (sz, base +' h));
        stroke 1pt lc (Gr.line (sz *' 2., base) (sz *' 2., base +' h));
        stroke 1pt lc (Gr.line (sz *' 3., base) (sz *' 3., base +' h));
        stroke 1pt lc (Gr.line (sz *' 4., base) (sz *' 4., base +' h));
        stroke 1pt lc (Gr.line (sz *' 5., base) (sz *' 5., base +' h));
        stroke 1pt lc (Gr.line (sz *' 6., base) (sz *' 6., base +' h));
        stroke 1pt lc (Gr.line (sz *' 7., base) (sz *' 7., base +' h));
        stroke 1pt lc (Gr.line (sz *' 8., base) (sz *' 8., base +' h));
        stroke 1pt lc (Gr.line (sz *' 9., base) (sz *' 9., base +' h));
        stroke 1pt lc (Gr.line (sz *' 10., base) (sz *' 10., base +' h));
        stroke 1pt lc (Gr.line (sz *' 11., base) (sz *' 11., base +' h));
        stroke 1pt lc (Gr.line (sz *' 12., base) (sz *' 12., base +' h));
        stroke 1pt lc (Gr.line (sz *' 13., base) (sz *' 13., base +' h));
        stroke 1pt lc (Gr.line (sz *' 14., base) (sz *' 14., base +' h));
        stroke 1pt lc (Gr.line (sz *' 15., base) (sz *' 15., base +' h));
        paint-k 1 1;
        paint-k 3 0;
        paint-k 3 2;
        paint-k 5 1;
        paint-k 7 0;
        paint-k 7 2;
        paint-k 9 1;
        paint-k 11 0;
        paint-k 11 2;
        paint-k 13 1;
      ]
        |> graffiti (arrow-up 1 1 3 2)
        |> graffiti (arrow-up 5 1 7 2)
        |> graffiti (arrow-up 9 1 11 2)
        |> graffiti (arrow-up 13 1 15 2)
        |> graffiti (arrow-up (- 1) 0 1 1)
        |> graffiti (arrow-up 3 0 5 1)
        |> graffiti (arrow-up 7 0 9 1)
        |> graffiti (arrow-up 11 0 13 1)
        |> graffiti (arrow-down 1 1 3 0)
        |> graffiti (arrow-down 5 1 7 0)
        |> graffiti (arrow-down 9 1 11 0)
        |> graffiti (arrow-down 13 1 15 0)
        |> graffiti (arrow-down (- 1) 2 1 1)
        |> graffiti (arrow-down 3 2 5 1)
        |> graffiti (arrow-down 7 2 9 1)
        |> graffiti (arrow-down 11 2 13 1) in
    '<
      +section ?:({ Writer: yasunori }) { |#id;: Long Chess Board| } <
        +frame {} <
          +p {
            縦 ${H \  \p{ 2 \leq H \leq 3}} ，横 ${W \  \p{H \leq W \leq 10^9}} の長方形の
            チェス盤があり，
            ナイトが ${\p{r_k, c_k}} に，ビショップが ${\p{r_b, c_b}} に置いてある．
          }
          +p { ナイトとビショップを移動させ，同じマスに移動させるのに必要な最小手数を求めよ． }
          +fig-center (let h = 35pt *' 3. in
          let base = 0pt in
          let w = 35pt *' 5. in
          let sz = 35pt in
          let lc = Color.gray 0.5 in
          let paint-k i j =
            let i = float i in
            let j = float j in
            let p = 1pt in
            let sx = sz *' i +' p in
            let sy = sz *' j +' p +' base in
            let gx = sz *' (i +. 1.) -' p in
            let gy = sz *' (j +. 1.) -' p +' base in stroke 2pt Color.red (Gr.rectangle (sx, sy) (gx, gy)) in
          let paint-b i j =
            let i = float i in
            let j = float j in stroke 2pt Color.blue (Gr.circle (sz *' i +' sz *' 0.5, sz *' j +' sz *' 0.5 +' base) (sz *' 0.5 -' 2pt)) in
          let paint-text ctx i j inner =
            let i = float i in
            let j = float j in
              draw-text (sz *' i +' sz *' 0.26, sz *' j +' sz *' 0.25 +' base) (read-inline (ctx
                |> set-font-size 23pt) inner) in
            from-graphics (w, h +' base) [
              stroke 1pt lc (Gr.line (0pt, base) (w, base));
              stroke 1pt lc (Gr.line (0pt, base +' sz) (w, base +' sz));
              stroke 1pt lc (Gr.line (0pt, base +' sz *' 2.) (w, base +' sz *' 2.));
              stroke 1pt lc (Gr.line (0pt, base +' sz *' 3.) (w, base +' sz *' 3.));
              stroke 1pt lc (Gr.line (0pt, base) (0pt, base +' h));
              stroke 1pt lc (Gr.line (sz, base) (sz, base +' h));
              stroke 1pt lc (Gr.line (sz *' 2., base) (sz *' 2., base +' h));
              stroke 1pt lc (Gr.line (sz *' 3., base) (sz *' 3., base +' h));
              stroke 1pt lc (Gr.line (sz *' 4., base) (sz *' 4., base +' h));
              stroke 1pt lc (Gr.line (sz *' 5., base) (sz *' 5., base +' h));
              paint-b 0 1;
              paint-b 1 2;
              paint-b 3 0;
              paint-k 4 2;
              paint-k 3 0;
            ]
              |> graffiti-given-context (fun ctx -> ([
              paint-text (set-text-color Color.blue ctx) 0 1 { B };
              paint-text (set-text-color Color.red ctx) 4 2 { K };
            ]))
              |> graffiti (Gr.arrow 1pt Color.red 12pt 10pt 4pt (140pt +' sz *' 0.25, 70pt) (105pt +' sz *' 0.75, 35pt))
              |> graffiti (Gr.arrow 1pt Color.blue 12pt 10pt 4pt (30pt, 65pt) (40pt, 75pt))
              |> graffiti (Gr.arrow 1pt Color.blue 12pt 10pt 4pt (65pt, 75pt) (110pt, 30pt)));
          +listing {
            * ナイトを ${\p{1, 5}} から ${\p{3, 4}} に移動させる．
            * ビショップを ${\p{2, 1}} から ${\p{1, 2}} に，${\p{1, 2}} から ${\p{3, 4}} に移動させる．
          }
          +p { この例では，答えは ${3} 手となる． }
        >
        +frame ?:(3) { 部分点1, 2解法 } <
          +listing { * ${W \text!{の総和\inline-skip(8pt);} \leq 1 0^5} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 各マスについてナイト/ビショップを移動させる最短手数を求めればよい． }
            +p { ${\to} ナイト/ビショップそれぞれBFSをすれば求められる！ }
            +block-skip (5pt);
            +p {
              盤面の高さがとても小さいため，ビショップが1手で動きうるマスは少ない．
              ビショップの移動先を全探索しても間に合う．
            }
          >
          +phantom (from 3) <
            +block-skip (5pt);
            +listing {
              * ${\mathrm{dist\_k}_{i , j} := \text!{ナイトをマス} ( i , j ) \text!{まで移動させる最短手数}}
              * ${\mathrm{dist\_b}_{i , j} := \text!{ビショップをマス} ( i , j ) \text!{まで移動させる最短手数}}
            }
            +p {
              とすれば，答えは
              ${\min_{1 \leq i \leq H , \  1 \leq j \leq W} \p{\mathrm{dist\_k}_{i , j} + \mathrm{dist\_b}_{i , j}}}．
            }
          >
        >
        +frame ?:(3) { 部分点3解法 } <
          +listing { * ${H = 2} }
          +block-skip (5pt);
          +phantom (from 2) <
            +listing {
              * ナイト，ビショップともに移動できるマスは一本道になっている．
              * 集合しうるマスは周期 ${4} で存在する．
              * 横方向に ${4} つ進むのに，ナイトは ${2}回，ビショップは ${4} 回かかる．
            }
          >
          +phantom (from 3) <
            +p { ${\to} ビショップに近い集合場所を ${2} つ調べればよい！ }
            +block-skip (5pt);
            +fig-center (let h = 70pt in
            let base = 60pt in
            let w = 525pt in
            let sz = 35pt in
            let lc = Color.gray 0.5 in
            let paint-k i j =
              let i = float i in
              let j = float j in
              let p = 1pt in
              let sx = sz *' i +' p in
              let sy = sz *' j +' p +' base in
              let gx = sz *' (i +. 1.) -' p in
              let gy = sz *' (j +. 1.) -' p +' base in stroke 2pt Color.red (Gr.rectangle (sx, sy) (gx, gy)) in
            let paint-b i j =
              let i = float i in
              let j = float j in stroke 2pt Color.blue (Gr.circle (sz *' i +' sz *' 0.5, sz *' j +' sz *' 0.5 +' base) (sz *' 0.5 -' 2pt)) in
            let paint-text ctx i j inner =
              let i = float i in
              let j = float j in
                draw-text (sz *' i +' sz *' 0.26, sz *' j +' sz *' 0.25 +' base) (read-inline (ctx
                  |> set-font-size 23pt) inner) in
              from-graphics (w, h +' base) [
                stroke 1pt lc (Gr.line (0pt, base) (w, base));
                stroke 1pt lc (Gr.line (0pt, base +' sz) (w, base +' sz));
                stroke 1pt lc (Gr.line (0pt, base +' sz *' 2.) (w, base +' sz *' 2.));
                stroke 1pt lc (Gr.line (0pt, base) (0pt, base +' h));
                stroke 1pt lc (Gr.line (sz, base) (sz, base +' h));
                stroke 1pt lc (Gr.line (sz *' 2., base) (sz *' 2., base +' h));
                stroke 1pt lc (Gr.line (sz *' 3., base) (sz *' 3., base +' h));
                stroke 1pt lc (Gr.line (sz *' 4., base) (sz *' 4., base +' h));
                stroke 1pt lc (Gr.line (sz *' 5., base) (sz *' 5., base +' h));
                stroke 1pt lc (Gr.line (sz *' 6., base) (sz *' 6., base +' h));
                stroke 1pt lc (Gr.line (sz *' 7., base) (sz *' 7., base +' h));
                stroke 1pt lc (Gr.line (sz *' 8., base) (sz *' 8., base +' h));
                stroke 1pt lc (Gr.line (sz *' 9., base) (sz *' 9., base +' h));
                stroke 1pt lc (Gr.line (sz *' 10., base) (sz *' 10., base +' h));
                stroke 1pt lc (Gr.line (sz *' 11., base) (sz *' 11., base +' h));
                stroke 1pt lc (Gr.line (sz *' 12., base) (sz *' 12., base +' h));
                stroke 1pt lc (Gr.line (sz *' 13., base) (sz *' 13., base +' h));
                stroke 1pt lc (Gr.line (sz *' 14., base) (sz *' 14., base +' h));
                stroke 1pt lc (Gr.line (sz *' 15., base) (sz *' 15., base +' h));
                paint-k 1 1;
                paint-k 3 0;
                paint-k 5 1;
                paint-k 7 0;
                paint-k 9 1;
                paint-k 11 0;
                paint-k 13 1;
                paint-b 0 1;
                paint-b 1 0;
                paint-b 2 1;
                paint-b 3 0;
                paint-b 4 1;
                paint-b 5 0;
                paint-b 6 1;
                paint-b 7 0;
                paint-b 8 1;
                paint-b 9 0;
                paint-b 10 1;
                paint-b 11 0;
                paint-b 12 1;
                paint-b 13 0;
                paint-b 14 1;
              ]
                |> graffiti-given-context (fun ctx -> ([
                paint-text (set-text-color Color.red ctx) 13 1 { K };
                paint-text (set-text-color Color.blue ctx) 4 1 { B };
                draw-text (120pt, 0pt) (read-inline ctx { ここだけ調べればよい！ });
              ]))
                |> graffiti (Gr.arrow 1pt Color.black 12pt 10pt 4pt (140pt, 20pt) (130pt, 57pt))
                |> graffiti (Gr.arrow 1pt Color.black 12pt 10pt 4pt (145pt, 20pt) (250pt, 57pt)));
          >
        >
        +frame ?:(2) { 部分点4解法 } <
          +listing { * ${H = 3} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { ${2} つのコマが十分離れている時を考える(近いときはBFS解法を使えばよい)． }
            +p { どちらのコマも ${1} 回の移動による横方向の移動距離は ${\max 2} ． }
            +p { ${\to} 答えは ${\ceil{\abs{c_k - c_b}\ /\ 2} + \p{\text!{小さい数}}} になることが分かる． }
            +p { 実は，殆どのケースで答えが ${\ceil{\abs{c_k - c_b}\ /\ 2}} になる！ }
          >
        >
        +frame ?:(4) { 部分点4解法 } <
          +listing { * ${H = 3} }
          +p { ナイトを以下のように動かすことを考えると，ナイトの位置は周期 ${4} になっている．\br; \phantom (from 2) { ${\to} ビショップの初期位置として ${3 \times 4} ケースを考えればよい． } }
          +select (only 1) <
            +fig-center (imageh3-fb-base);
          > <
            +select (only 2) <
              +fig-center (imageh3-fb-base
                |> graffiti [
                let p = 3pt in stroke 3pt (Color.gray 0.2) (Gr.rectangle-round 4pt (sz *' 9. -' p, base -' p) (sz *' 13. +' p, base +' h +' p));
              ]);
            > <
              +fig-center (imageh3-fb-base
                |> graffiti [
                let p = 3pt in stroke 3pt (Color.gray 0.2) (Gr.rectangle-round 4pt (sz *' 9. -' p, base -' p) (sz *' 13. +' p, base +' h +' p));
                let paint-b i j =
                  let i = float i in
                  let j = float j in stroke 2pt Color.blue (Gr.circle (sz *' i +' sz *' 0.5, sz *' j +' sz *' 0.5 +' base) (sz *' 0.5 -' 2pt)) in paint-b 11 1;
              ]);
            >
          >
          +phantom (from 3) <
            +p { この ${1 2} マスのうち， ${\ceil{\abs{c_k - c_b} \ / \ 2}} が達成できないのは 図の位置にビショップがある時のみ． }
          >
          +phantom (from 4) <
            +p {
              このとき，答えは ${\ceil{\abs{c_k - c_b} \ / \ 2} + 1} ，
              それ以外では ${\ceil{\abs{c_k - c_b} \ / \ 2}} となる．
            }
          >
        >
      >
    >
let-block +lcm-and-gcd id =
  let id = embed-string id in
  let-math \gcd = ${\mathrm{gcd}} in
  let-math \lcm = ${\mathrm{lcm}} in
  let-math \red inner = math-color Color.red inner in
  let-math \blue inner = math-color Color.blue inner in
  let-math \purple inner = math-color (Color.of-css `#ff00ff`) inner in
    '<
      +section ?:({ Writer: yasunori }) { |#id;: LCM and GCD| } <
        +frame {} <
          +p {
            黒板に ${N \  \p{2 \leq N \leq 10^5}} 個の
            正整数 ${A_1 , A_2 , \ldots , A_N \( 1 \leq A_i \leq 2 \times 1 0^5 )} が書かれている．
          }
          +block-skip (5pt);
          +p {
            次の操作を行えなくなるまで繰り返す:
            \listing {
              * 黒板に書かれている数を ${2} つ選んで消す．消した数を ${x , \  y} として，\br; ${\mathrm{lcm} ( x , \  y )} と ${\mathrm{gcd} ( x , \  y )}を黒板に書き加える．
               ** ただし，操作の前後で黒板の数の組み合わせが変化しないような操作は行えない．
            }
          }
          +block-skip (5pt);
          +p {
            操作を行えなくなるまで繰り返したのち，
            黒板に書かれているすべての数字を昇順に並び替え，各要素を ${9 9 8 2 4 4 3 5 3} で割った余りを求めよ．
          }
        >
        +frame ?:(2) { 部分点1解法 } <
          +listing { * ${N = 2} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p {
              操作を ${2} 回以上行うことはできないため，答えは
              \eqn (${\pb{
                \mathrm{gcd}\p{A_1, A_2} \mod 998244353,
                \mathrm{lcm}\p{A_1, A_2} \mod 998244353
              }}); となる．
            }
            +block-skip (5pt);
            +p {
              ${\mathrm{mod}} を取らないとWAとなるため注意！ \br; たとえば ${A = \pb{199999, 200000}} のとき，
              ${\mathrm{lcm} ( 1 9 9 9 9 9 , 2 0 0 0 0 0 ) = 3 9 9 9 9 8 0 0 0 0 0} ．
            }
          >
        >
        +frame ?:(3) { 部分点2解法 } <
          +listing { * ${N \leq 1 0 0 0 , \  \mathrm{lcm} \p{A_1, A_2, \ldots, A_N} \leq 1 0^{1 8}} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 実は，操作後の数列の最小値は ${\mathrm{gcd} \p{ A_1 , A_2 , \ldots , A_N }} となる． }
            +p { 証明: ${g = \mathrm{gcd} \p{A_1, A_2, \ldots, A_N}} とする． }
            +listing {
              * ${A_1 , A_2 , \ldots , A_N} はすべて ${g} の倍数である．
              また，選んだ ${2} つの数がともに ${g} の倍数の時，新たに書き加える数は ${2} つとも ${g} の倍数．\br; ${\to} 何度操作を行っても，黒板に ${g} の倍数以外が書かれることはない．
              * ${i = 2 , 3 , \ldots , N} に対して， ${( A_1 , A_i )} の ${2} つの数を選んで操作を行うことで，
              ${g} を作ることができる．
            }
          >
          +phantom (from 3) <
            +p { ${g} を除いて同じことを繰り返すことで，答えを求めることができる！ }
            +p { 操作回数は ${N ( N - 1 ) / 2} 回なので，十分高速． }
          >
        >
        +frame ?:(2) { 満点解法 } <
          +p {
            \align [
              ${A_1 =};
              ${2^\blue{2} \times 3^\red{4} \times 5^\blue{5}};
              ${A_2 =};
              ${2^\red{6} \times 3^\blue{3} \times 5^\red{7}};
              ${\downarrow};
              ${};
              ${\mathrm{gcd} \p{A_1, A_2} =};
              ${2^\blue{2} \times 3^\blue{3} \times 5^\blue{5}};
              ${\mathrm{lcm} \p{A_1, A_2} =};
              ${2^\red{6} \times 3^\red{4} \times 5^\red{7}};
            ]; 問題の操作は，素因数ごとに肩の数の大きいほうを集めると ${\mathrm{lcm}}に，
            小さいほうを集めると ${\mathrm{gcd}}になることが分かる．
          }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { ${\to} 肩の数を素因数ごとにソートしたものが答えになる！ }
          >
        >
      >
      +frame ?:(2) { 満点解法 } <
        +p { たとえば ${A = \pb{20, 75, 144}} では， }
        +alignat (3) [
          ${A_1 =};
          ${2^\purple{2} \times 3^\blue{0} \times 5^\purple{1}};
          ${};
          ${};
          ${B_1 =};
          ${2^\blue{0} \times 3^\blue{0} \times 5^\blue{0}};
          ${A_2 =};
          ${2^\blue{0} \times 3^\purple{1} \times 5^\red{2}};
          ${\to};
          ${};
          ${B_2 =};
          ${2^\purple{2} \times 3^\purple{1} \times 5^\purple{1}};
          ${A_3 =};
          ${2^\red{4} \times 3^\red{2} \times 5^\blue{0}};
          ${};
          ${};
          ${B_3 =};
          ${2^\red{4} \times 3^\red{2} \times 5^\red{2}};
        ];
        +p { これより，操作後の数列は ${\pb{1, 60, 3600}} となる． }
        +block-skip (5pt);
        +phantom (from 2) <
          +p {
            ${2 \times 1 0^5} 以下の正整数について，素因数の種類は高々 ${6} 個なため，
            ソートする要素の個数は最大で ${6 \times N}．このため，各素因数について指数が ${1}以上であるもののみソートすれば間に合う．
          }
        >
      >
    >
let-block +deque-inversion id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: Nichi10p }) { |#id;: Deque Inversion| } <
        +frame {} <
          +p { 最初，長さ ${N \  ( 2 \leq N \leq 1 0^5 )} の数列 ${A \  ( - 1 0^5 \leq A_i \leq 1 0^5 )} がある． }
          +p { 以下のクエリが ${Q \  ( 1 \leq Q \leq 1 0^5 )} 個来るので，各クエリ操作後の ${A} の転倒数を求めよ． }
          +listing {
            * `1 x` : ${A} の\emph { 末尾 }に ${x}を追加する．
            * `2` : ${A} の\emph { 末尾 }を取り除く．
            * `3 x` : ${A} の\emph { 先頭 }に ${x} を追加する．
            * `4` : ${A} の \emph { 先頭 } を取り除く．
          }
          +block-skip (5pt);
          +p { ここで，操作の途中で ${A} の長さは ${2} より小さくなることはない． }
        >
        +frame ?:(3) { 部分点1, 2解法 } <
          +listing { * ${N \leq 1 0 0 , \  Q \leq 1 0 0} \phantom (until 2) { ${, \  \text!{クエリは 1, 2 のみ}} } }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { \emph { 末尾 }に追加 or 削除 クエリが飛んでくる \br; ${\to} 可変長配列で管理可能！ }
            +listing {
              * C++ : `vector` の `push_back` と `pop_back`
              * Python: `list` の `append` と `pop`
            }
            +p { 各クエリに従って配列 ${A} を更新後，愚直に転倒数を求めれば間に合う． }
          >
          +block-skip (5pt);
          +phantom (from 3) <
            +p { \emph { 先頭 } への操作が来ても... 配列 ${A} を新たに作り直したりすればOK． }
            +p { 転倒数を求めるパートで毎回数列 ${A} の要素の個数の ${2} 乗回程度計算が行われるため，全体で計算量は悪化しない． }
          >
        >
        +frame ?:(3) { 部分点3解法 } <
          +listing { * ${N \leq 2 \times 1 0^4 , \  Q \leq 1 0 0} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 転倒数を高速に求めたい ${\to} BIT(fenwick tree) で求められる！ }
            +p { 転倒数とは，「"自分より左にある，自分より大きな数の個数" の総和」 }
          >
          +block-skip (2pt);
          +phantom (from 3) <
            +p {
              ${i = 1 , 2 , \ldots , \mathrm{len} ( A )} について，
              \listing {
                * ${A_i} より大きい数の個数をBITにより求める．
                 ** いま BIT で管理しているのは「自分より左にある数」
                * BITの ${A_i} の値を ${1} 増やす．
              } とすれば，転倒数が求められる．
            }
            +p { このままだと負の数が出てくるが，あらかじめ ${1 0^5} を足しておけばよい． }
          >
        >
        +frame ?:(3) { 満点解法 } <
          +phantom (from 2) <
            +p {
              操作により転倒数がどう変化するかを考える．
              \listing {
                * ある数 ${x} が ${A} の\emph { 末尾 }に追加されるとき\br; ${\to} 転倒数は「 ${A} のうち ${x} より大きい数の個数」ぶん増える．
                * ある数 ${x} が ${A} の\emph { 末尾 }から取り除かれるとき\br; ${\to} 転倒数は「 ${A} のうち ${x} より大きい数の個数」ぶん減る．
                * ある数 ${x} が ${A} の\emph { 先頭 }に追加されるとき \br; ${\to} 転倒数は「 ${A} の ${x} より小さい数の個数」ぶん増える．
                * ある数 ${x} が ${A} の\emph { 先頭 } から取り除かれるとき\br; ${\to} 転倒数は「 ${A} の ${x} より小さい数の個数」ぶん減る．
              }
            }
          >
        >
        +block-skip (2pt);
        +phantom (from 3) <
          +p { ${A} の各値の個数をBITを使って管理すれば，高速にこの問題をACできる！ }
        >
      >
    >
let-block +colorful-balls id =
  let id = embed-string id in
    '<
      +section ?:({ Writer: Ackvy }) { |#id;: Colorful Balls| } <
        +frame {} <
          +block-skip (5pt);
          +p { 左のほうが空いている筒と， ${1} 以上 ${1 0^9} 以下の整数で表される色が塗られたボールがたくさんある． }
          +block-skip (5pt);
          +p {
            以下のクエリを処理せよ．
            \listing {
              * `1 x c`: 色 ${c} のボールを左から ${x} 個追加する．
              * `2 x`: 現在の筒の左から ${1 , 2 , \ldots , x} 番目のボールを取り除く．
              * `3 x`: 現在の筒の左から ${x} 番目のボールの色を出力する．
            }
          }
        >
        +frame ?:(2) { 部分点1解法 } <
          +listing { * ${Q \leq 5 0 0 0 , \  \text!{クエリ1, 2 に対して常に} x = 1} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { ボールが ${1} つの更新しかないので，そのままシミュレーションすればOK． }
            +block-skip (5pt);
            +p { クエリが高々 ${5 0 0 0} 回しか来ないので，毎回愚直に先頭にボールを追加しても間に合う． }
          >
        >
        +frame ?:(2) { 部分点2解法 } <
          +listing { * ${Q \leq 5 0 0 0} }
          +block-skip (5pt);
          +phantom (from 2) <
            +p { 一度にたくさんのボールの追加があるため，愚直にシミュレーションすると MLE / TLE してしまう． }
            +block-skip (5pt);
            +p {
              ${\to} 「${i} 番目に， ${c_i} 色のボールが ${a_i} 個ある」
              という情報を持っておけば，愚直にシミュレーション可能！
            }
          >
        >
        +frame ?:(2) { 満点解法 } <
          +p {
            部分点2と同様，
            「${i} 番目に， ${c_i} 色のボールが ${a_i} 個ある」
            という情報を持っておく．
            \listing {
              * 逆から見れば，クエリ1は末尾に追加の操作になるため，高速．
              * クエリ2で消す回数は，クエリ1の個数で抑えられるため問題ない．
            }
          }
          +block-skip (5pt);
          +phantom (from 2) <
            +p {
              クエリ3が問題だが ${\ldots} \br;
              ${\to} ボールの個数の累積和を持っておくことで，二分探索できる！
            }
            +block-skip (5pt);
            +p { ${\text!{個数の総和} - \  x} を二分探索すればOK． }
          >
        >
      >
    >
let-mutable team-cnt <- 0
let-block ctx +set-team-cnt cnt =
  let () = team-cnt <- cnt in block-nil
let-block ctx +statistics score ofa otime fa time =
  let ac =
    match (List.find (fun (a, _) -> a == 100) score) with
      | Some(_, c) -> c
      | None -> 0 in
  let ac-cnt =
    let num = embed-string (arabic ac) in
    let den = embed-string (arabic !team-cnt) in { #num; / #den; } in
  let ac-per =
    let per = 100 * ac * 100 / !team-cnt in
    let num = embed-string ((arabic (per / 100) ^ `.` ^ (arabic (per mod 100)))) in { #num; \% } in
  let ave =
    let (sum, cnt) = List.fold (0, 0) (fun (a, b) (sum, cnt) -> (sum + a * b, cnt + b)) score in
    let per = sum * 100 / !team-cnt in
    let num = embed-string ((arabic (per / 100) ^ `.` ^ (arabic (per mod 100)))) in { #num; 点 } in
    read-block ctx '<
      +frame { 統計情報 } <
        +block-skip (70pt);
        +easytable ?:[] [c;c;] {
          |AC数| #ac-cnt;
          |AC率| #ac-per;
          |平均点| #ave;
          | |
          |オンサイトFA| #ofa; (#otime;)
          | FA | #fa; (#time;)
          |
        }
      >
    >
let color-list =
  [
    (10, Color.of-css `#E6F6FF`);
    (20, Color.of-css `#CCECFF`);
    (30, Color.of-css `#B3E2FF`);
    (40, Color.of-css `#99D9FF`);
    (50, Color.of-css `#80CFFF`);
    (60, Color.of-css `#66C5FF`);
    (70, Color.of-css `#4DBBFF`);
    (80, Color.of-css `#33B1FF`);
    (90, Color.of-css `#1AA7FF`);
    (100, Color.of-css `#008DFF`);
  ]
let-block ctx +graph problems =
  let (width, height) = (600pt, 300pt) in
  let cnt = List.length problems in
  let sz = width *' (1. /. (float cnt)) in
  let-mutable base <- 0pt in
  let low = 42pt in
  let draw (name, score) =
    let name = read-inline ctx (embed-string name) in
    let pad = 8pt in
    let one = (height -' low) *' (1. /. (float !team-cnt)) in
    let-mutable nh <- 0pt in
    let paint (score, cnt) =
      let h = one *' (float cnt) in
      let color =
        match List.find (fun (a, _) -> a == score) color-list with
          | Some(_, c) -> c
          | None -> Color.black in
      let res = fill color (Gr.rectangle (!base +' pad, low +' !nh) (!base +' sz -' pad, low +' !nh +' h)) in
      let () = nh <- !nh +' h in res in
    let ac =
      let ac =
        match List.find (fun (a, _) -> a == 100) score with
          | Some(_, c) -> c
          | None -> 0 in read-inline ctx (embed-string (`(` ^ (arabic ac) ^ `)`)) in
    let res =
      List.append [
        draw-text (!base +' sz *' 0.5 -' (get-natural-width name) *' 0.5, 20pt) name;
        draw-text (!base +' sz *' 0.5 -' (get-natural-width ac) *' 0.5, 0pt) ac;
      ] (List.map paint (List.reverse score)) in
    let () = base <- !base +' sz in res in
    read-block ctx '<
      +frame { 統計 } <
        +block-skip (5pt);
        +fig-center (from-graphics (width, height) (List.concat [
          [
            stroke 1pt Color.black (Gr.line (0pt, low) (width, low));
          ];
          List.concat (List.map draw problems);
        ]));
      >
    >
let score-A = [(100, 94);]
let score-B =
  [
    (20, 9);
    (40, 13);
    (70, 4);
    (100, 30);
  ]
let score-C =
  [
    (50, 9);
    (100, 64);
  ]
let score-D =
  [
    (20, 2);
    (60, 5);
    (100, 21);
  ]
let score-E =
  [
    (20, 1);
    (40, 1);
    (100, 34);
  ]
let score-F =
  [
    (20, 7);
    (100, 60);
  ]
let score-G =
  [
    (20, 1);
    (40, 2);
    (50, 3);
    (100, 6);
  ]
let score-H =
  [
    (10, 15);
    (50, 7);
    (100, 29);
  ]
let score-I =
  [
    (10, 1);
    (20, 3);
    (100, 62);
  ]
let score-J =
  [
    (20, 3);
    (50, 2);
    (100, 63);
  ]
let score-K =
  [
    (10, 3);
    (40, 5);
    (100, 52);
  ]
in

CyanTheme.document '<
  +make-title ((|
    title = { |水以下コンテスト 解説| };
    author = { |Kyo_s_s, yasunori, Ackvy, えくと,| forループ, Nichi10p, Blueberry1001, ragna| };
    date = { |2024/03/30| };
  |));
  +set-team-cnt (96);

  +frame { ごめんなさい } <
    +block-skip (15pt);
    +p { J: Counting Zig Zag Sequence にて，部分点1の制約で誤って部分点2が設定されていました． }
    +p { コンテスト終了間際に発覚してしまい，申し訳ございません． }
    +block-skip (5pt);
  >

  +frame { アンケートのお願い } <
    +block-skip (5pt);
    +p { アンケートにご協力いただけると嬉しいです． }
    +block-skip (10pt);
    +fig-center (include-image 220pt `images/survey.jpg`);
  >

  +frame { 優勝 } <
    +block-skip (40pt);
    +easytable ?:[] [c;c;c;] {
      | オンサイト優勝| magepika | (980点, 3:40:08)
      | オンサイト2位| shinchan | (900点, 2:28:55)
      | オンサイト3位| ochiaigawara | (850点, 4:09:24)
      | | |
      | 全体優勝 | ssrs | (1100点，1:42:19)
      |
    }
  >

  +graph [
    (`A`, score-A);
    (`B`, score-B);
    (`C`, score-C);
    (`D`, score-D);
    (`E`, score-E);
    (`F`, score-F);
    (`G`, score-G);
    (`H`, score-H);
    (`I`, score-I);
    (`J`, score-J);
    (`K`, score-K);
  ];

  +cyan-or-less (`A`);
  +statistics (score-A) { shinchan } { 2:31 } { shinchan } { 2:31 }
  +ffffx (`B`);
  +statistics (score-B) { takumi152 } { 37:20 } { kude } { 17:54 }
  +unions (`C`);
  +statistics (score-C) { AngrySadEight } { 10:57 } { TKTYI } { 3:25 }
  +x-word-database (`D`);
  +statistics (score-D) { deuteridayo } { 57:47 } { ssrs } { 27:13 }
  +range-rotate-query (`E`);
  +statistics (score-E) { porkleoi } { 43:27 } { potato167 } { 42:01 }
  +subset-mex (`F`);
  +statistics (score-F) { magepika } { 10:23 } { magepika } { 10:23 }
  +long-chess-board (`G`);
  +statistics (score-G) { startcpp } { 2:47:57 } { ssrs } { 1:04:25 }
  +lcm-and-gcd (`H`);
  +statistics (score-H) { shogo314 } { 20:37 } { TKTYI } { 11:29 }
  +deque-inversion (`I`);
  +statistics (score-I) { AngrySadEight } { 23:16 } { dyktr_06 } { 8:16 }
  +counting-zig-zag-sequence (`J`);
  +statistics (score-J) { n_o_n_o_n } { 14:31 } { potato167 } { 9:10 }
  +colorful-balls (`K`);
  +statistics (score-K) { cyanorless_tanto } { 12:14 } { potato167 } { 6:29 }
>
